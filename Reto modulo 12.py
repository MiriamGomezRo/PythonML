# -*- coding: utf-8 -*-
"""FR-M12-MiriamGomezRodriguez. ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sNQT-8YX5GfGvGP368suVjakoaaL6S4v
"""

import networkx as nx
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from itertools import count
import matplotlib.colors as mcolors
import warnings

warnings.filterwarnings('ignore')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from google.colab import drive
drive.mount('/content/drive')

""" **Crear Dataframe**"""

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Modulo 12/Reto/email-enron-only[1].mtx',
                 sep=' ',
                 header=None,
                 names=['t', 'i'])

df

"""**Dibujar la red**"""

g = nx.from_pandas_edgelist(df, 't' , 'i')
nx.draw_networkx(g)
plt.figure(figsize=(40,40))

"""*   Cual es el nodo con el grado maximo ?
*   Cual es el nodo con el grado minimo?
*   Cual es el diametro de la red?
*   Cual es la distancia promedio mas corta?
*   Es una red bipartita?

Diametro
"""

nx.diameter(g)

"""Distancia promedio mas corta"""

def path_length_histogram(g, title=None):
  # Find path lengths
  length_source_target = dict(nx.shortest_path_length(g))
  # Convert dict of dicts to flat list
  all_shortest = sum(
      [list(length_target.values()) for length_target in length_source_target.values()],
      [])
  # Calculate integer bins
  high = max(all_shortest)
  bins = [-0.5 + i for i in range(high + 2)]
  # Plot histogram
  plt.hist(all_shortest, bins=bins, rwidth=0.8)
  plt.title(title)
  plt.xlabel("Distance")
  plt.ylabel("Count")

path_length_histogram(g, title='Correos')

"""grados maximo y minimo"""

# node position for plotting
pos = nx.spring_layout(g)

def draw_net(G, pos, measures, measure_name):

    plt.figure(figsize=(20,20))
    nodes = nx.draw_networkx_nodes(G, pos, node_size=150, cmap=plt.cm.plasma,
                                   node_color=list(measures.values()),
                                   nodelist=measures.keys())
    nodes.set_norm(mcolors.SymLogNorm(linthresh=0.01, linscale=1, base=10))
    labels = nx.draw_networkx_labels(G, pos)
    edges = nx.draw_networkx_edges(G, pos, alpha=0.2)

    plt.title(measure_name)
    plt.colorbar(nodes)
    plt.axis('off')
    plt.show()

degree_centrality=dict(g.degree())

draw_net(g, pos,degree_centrality, 'Centralidad de Grado')

deg_cen = [(k, v) for k, v in sorted(degree_centrality.items(), key=lambda item: -item[1])]
most_important= deg_cen[0:5]
most_important

less_important= deg_cen[0:-1]
less_important

"""Es una Red Bipartita ? No

Cuantos y cuales nodos hay que remover para que la red sea disconexa?
Cuantos y cuales arcos hay que remover para que la red sea disconexa?
En base a lo anterior , La red es resistente ante fallas, cambios o errores que pudieran ocurrir ?

Nodos Importantes : 105, 92
"""

is_disconnected = not nx.is_connected(g)
if is_disconnected:

    components = nx.connected_components(G)
    num_components = nx.number_connected_components(G)

    print("El grafo es disconexo.")
    print(f"Número de componentes conexas: {num_components}")
    print("Componentes conexas:")
    for component in components:
        print(component)
else:
    print("El grafo es conexo.")

import networkx.algorithms.connectivity as nxcon

"""Arcos a quitar"""

nxcon.minimum_st_edge_cut(g, 105, 92)

"""Nodos a quitar"""

nxcon.minimum_st_node_cut(g, 105, 92)

"""En base a lo anterior, la red es resistente ante fallas, cambios o errores que puedan ocurrir ? **si es resistente **

**Pendiente : Una vez encontrados los nodos y arcos del paso anterior , identificalos con un color diferente en la visualizacion de la red **

Calcular y visualizar las centralidades de la red, Las centralidades miden la importancia de los nodos basados en diferentes criterios . Basado en diferentes definiciones de importancia de un nodo, calcula la centralidad de grado, de intermediacion y cercania. Muestra con un color diferente en la red los 10 nodos mas importantes para cada centralidad

**Centralidad de grado **
"""

degree_centrality=dict(g.degree())

draw_net(g, pos,degree_centrality, 'Centralidad de Grado')

deg_cen = [(k, v) for k, v in sorted(degree_centrality.items(), key=lambda item: -item[1])]
most_important= deg_cen[0:10]
most_important

"""*Centralidad de intermediacion *"""

betweenness = nx.betweenness_centrality(g)

bet_cen = [(k, v) for k, v in sorted(betweenness.items(), key=lambda item: -item[1])]
bet_cen[0:10]

draw_net(g, pos, betweenness, 'Betweenness Centrality')

"""Centralidad de Cercania"""

closeness = nx.closeness_centrality(g)

closeness_cen = [(k, v) for k, v in sorted(closeness.items(), key=lambda item: -item[1])]
closeness_cen[0:10]

draw_net(g, pos, closeness, 'Closeness Centrality')

"""Crear una red dirigida, ahora si importa quien manda el correo y quien lo recibe. En esta nueva red calcula el PageRank de los nodos y visualizarlos en la red

**Centralidad de PageRank **
"""

pagerank = nx.pagerank(g)
pagerank

pagerang_cen = [(k, v) for k, v in sorted(pagerank.items(), key=lambda item: -item[1])]
pagerank_most_important=pagerang_cen[0:10]
pagerank_most_important

"""**Crea una red ridigida ahora si quien manda el correo y quien lo recibe , En esta nueva red calcula el page rank de los nodos y visualizalos en la red**

Page Rank
"""

draw_net(g, pos, pagerank, 'PageRank Centrality')

"""**Red Dirigida**"""

tupla = tuple(df.to_records(index=False))
tupla

DiGraf  = nx.DiGraph()
DiGraf.add_edges_from(tupla)
nx.draw_networkx(DiGraf)

"""**Red Dirigida con PageRank**"""

draw_net(DiGraf, pos, pagerank, 'PageRank Centrality')

"""**Resistencia a ataques o fallas**"""

nx.density(g)

def random_node(g): # select a random node from graph
    return [np.random.choice(g.nodes())]

def dismantle(g, function, **args): # incrementally removes node from a graph and computes size of connected components
    total_nodes = g.number_of_nodes()
    removed_nodes = []
    components = []
    while len(g.nodes()) > 1:
        n = function(g, **args)[0]
        g.remove_node(n)
        removed_nodes.append((len(removed_nodes)+1)/total_nodes)
        comps = list(nx.connected_components(g))
        g_size = 0
        if len(comps)>0:
            g_size  = max([len(c)for c in comps])/total_nodes
        components.append(g_size)
    return removed_nodes, components

def get_sorted_nodes(g, score, reverse=True):
    nodes = score(g)
    if isinstance(nodes, dict):
        nodes = [(k, v) for k, v in nodes.items()]
    srt = sorted(nodes, key = lambda k: k[1], reverse = reverse)
    return [x[0] for x in srt]

def plot_dismantle(x, y):
    plt.plot(x, y)
    plt.xlabel("Removed Nodes")
    plt.ylabel("Giant Component size")
    plt.show()

red_ante_fallas = g.copy()
rn, comps = dismantle(red_ante_fallas, random_node)
plot_dismantle(rn, comps)

"""**Cortes entre nodos importantes**"""

nxcon.minimum_st_edge_cut(g, 105, 92)
nxcon.minimum_st_node_cut(g, 105, 92)

"""Conclusiones
* Total de empleados , total de interacciones por correo electronico?

* Quien tiene el maximo grado , quien el minimo y que significa? **(Grado: la cantidad de amigos que tiene conectados a el ) segun la centralidad de grado el que tiene mas es el 105 con 42 y el que menos tiene son los siguientes nodos**

 **(15, 1),**
 **(42, 1)**,
 **(63, 1),**
 **(80, 1),**
 **(92, 1)**

* Cual es el diametro de la red y que significa ? **el diametro es de 8 (Diametro: es la mayor distancia entre dos puntos de la misma)**
* Cual es el promedio de los caminos mas cortos y que significa ? **la distancia promedio es de 5 y significa que debe de haber 5 interacciones entre nodos**

* La red es robusta ? como reacciona el sistema ante fallas o ataques? **La red es robusta**

* Tomando en cuenta las 3 medidas de centralidad ¿cuales son los nodos mas importantes? **Segun las 3 centralidades el mas importante es el 105**


* Segun el PageRank ¿quien es el nodo mas importante ? Y en base a que es si importancia ? **el nodo 105 es el mas importante segun Page Rank**

**Numero de empleados**
"""

print('número de empleados: {}'.format(g.number_of_nodes()))

"""**Numero de interacciones**"""

print('número de interacciones: {}'.format(g.number_of_edges()))

# * Total de empleados , total de interacciones por correo electronico? son 623 interacciones en total

df.groupby(by=["t", "i"]).sum()
# se quito el nodo 141 y 92 se desconectaron con la instruccion afectando el dataframe
#nxcon.minimum_st_edge_cut(g, 105, 92)
#nxcon.minimum_st_node_cut(g, 105, 92)